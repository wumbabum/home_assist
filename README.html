<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Before running the application you will need a working PostgreSQL installation and a valid DSN (data source name) for connecting to the database.</p>
<p>Please open the <code>cmd/web/main.go</code> file and edit it to include your valid DSN as the default value.</p>
<pre>
cfg.db.dsn = env.GetString("DB_DSN", "YOUR DEFAULT DSN GOES HERE")
</pre>
<p>Note that this DSN must be in the format <code>user:pass@localhost:port/db</code> and <strong>not</strong> be prefixed with <code>postgres://</code>.</p>
<p>Make sure that you're in the root of the project directory, fetch the dependencies with <code>go mod tidy</code>, then run the application using <code>go run ./cmd/web</code>:</p>
<pre>
$ go mod tidy
$ go run ./cmd/web
</pre>
<p>Then visit <a href="http://localhost:5749">http://localhost:5749</a> in your browser.</p>
<p>You can also start the application with live reload support by using the <code>run</code> task in the <code>Makefile</code>:</p>
<pre>
$ make run
</pre>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>assets</code></strong></td>
<td>Contains the non-code assets for the application.</td>
</tr>
<tr>
<td><code>↳ assets/migrations/</code></td>
<td>Contains SQL migrations.</td>
</tr>
<tr>
<td><code>↳ assets/static/</code></td>
<td>Contains static UI files (images, CSS etc).</td>
</tr>
<tr>
<td><code>↳ assets/templates/</code></td>
<td>Contains HTML templates.</td>
</tr>
<tr>
<td><code>↳ assets/efs.go</code></td>
<td>Declares an embedded filesystem containing all the assets.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>cmd/web</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/web/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/web/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/web/helpers.go</code></td>
<td>Contains helper functions for common tasks.</td>
</tr>
<tr>
<td><code>↳ cmd/web/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/web/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/web/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
<tr>
<td><code>↳ cmd/web/server.go</code></td>
<td>Contains a helper functions for starting and gracefully shutting down the server.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/database/</code></td>
<td>Contains your database-related code (setup, connection and queries).</td>
</tr>
<tr>
<td><code>↳ internal/env</code></td>
<td>Contains helper functions for reading configuration settings from environment variables.</td>
</tr>
<tr>
<td><code>↳ internal/funcs/</code></td>
<td>Contains custom template functions.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding HTML forms, JSON requests, and URL query strings.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for rendering HTML templates and sending JSON responses.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via environment variables, with the environment variables read into your application in the <code>run()</code> function in the <code>main.go</code> file.</p>
<p>You can try this out by setting a <code>HTTP_PORT</code> environment variable to configure the network port that the server is listening on:</p>
<pre>
$ export HTTP_PORT="9999"
$ go run ./cmd/web
</pre>
<p>Feel free to adapt the <code>run()</code> function to parse additional environment variables and store their values in the <code>config</code> struct. The application uses helper functions in the <code>internal/env</code> package to parse environment variable values or return a default value if no matching environment variable is set. It includes <code>env.GetString()</code>, <code>env.GetInt()</code> and <code>env.GetBool()</code> functions for reading string, integer and bool values from environment variables. Again, you can add any additional helper functions that you need.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</pre>
<p>Handlers are defined in the <code>cmd/web/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>run()</code> function <code>cmd/web/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/web/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/go-chi/chi">chi</a> version 5 is used for routing. Routes are defined in the <code>routes()</code> method in the <code>cmd/web/routes.go</code> file. For example:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    
    mux.Get("/your/path", app.yourHandler)
    
    return mux
}
</pre>
<p>For more information about chi and example usage, please see the <a href="https://github.com/go-chi/chi">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/web/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</pre>
<p>You can then register this middleware with the router using the <code>Use()</code> method:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)
    
    mux.Get("/your/path", app.yourHandler)
    
    return mux
}
</pre>
<p>It's possible to use middleware on specific routes only by creating route 'groups':</p>
<pre>
func (app *application) routes() http.Handler {
    mux := chi.NewRouter()
    mux.Use(app.yourMiddleware)
    
    mux.Get("/your/path", app.yourHandler)

    mux.Group(func(mux chi.Router) {
        mux.Use(app.yourOtherMiddleware)
    
        mux.Get("/your/other/path", app.yourOtherHandler)
    })
    
    return mux
}
</pre>
<p>Note: Route 'groups' can also be nested.</p>
<h2>Rendering HTML templates</h2>
<p>HTML templates are stored in the <code>assets/templates</code> directory and use the standard library <code>html/template</code> package. The structure looks like this:</p>
<table>
<tbody>
<tr>
<td><code>assets/templates/base.tmpl</code></td>
<td>The 'base' template containing the shared HTML markup for all your web pages.</td>
</tr>
<tr>
<td><code>assets/templates/pages/</code></td>
<td>Directory containing files with the page-specific content for your web pages. See <code>assets/templates/pages/home.tmpl</code> for an example.</td>
</tr>
<tr>
<td><code>assets/templates/partials/</code></td>
<td>Directory containing files with 'partials' to embed in your web pages or base template. See <code>assets/templates/partials/footer.tmpl</code> for an example.</td>
</tr>
</tbody>
</table>
<p>The HTML for web pages can be sent using the <code>response.Page()</code> function. For convenience, an <code>app.newTemplateData()</code> method is provided which returns a <code>map[string]any</code> map. You can add data to this map and pass it on to your templates.</p>
<p>For example, to render the HTML in a <code>assets/templates/pages/example.tmpl</code> file:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := app.newTemplateData()
    data["hello"] = "world"

    err := response.Page(w, http.StatusOK, data, "pages/example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := app.newTemplateData()
    data["hello"] = "world"

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.PageWithHeaders(w, http.StatusOK, data, headers, "pages/example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<p>Note: All the files in the <code>assets/templates</code> directory are embedded into your application binary and can be accessed via the <code>EmbeddedFiles</code> variable in <code>assets/efs.go</code>.</p>
<h2>Adding default template data</h2>
<p>If you have data that you want to display or use on multiple web pages, you can adapt the <code>newTemplateData()</code> helper in the <code>helpers.go</code> file to include this by default. For example, if you wanted to include the current year value you could adapt it like this:</p>
<pre>
func (app *application) newTemplateData() map[string]any {
    data := map[string]any{
        "CurrentYear": time.Now().Year(),
    }

    return data
}    
</pre>
<h2>Custom template functions</h2>
<p>Custom template functions are defined in <code>internal/funcs/funcs.go</code> and are automatically made available to your HTML templates when you use <code>response.Page()</code> .</p>
<p>The following custom template functions are already included by default:</p>
<table>
<tbody>
<tr>
<td><code>now</code></td>
<td>Returns the current time.</td>
</tr>
<tr>
<td><code>timeSince arg1</code></td>
<td>Returns the time elapsed since arg1.</td>
</tr>
<tr>
<td><code>timeUntil arg2</code></td>
<td>Returns the time until arg1.</td>
</tr>
<tr>
<td><code>formatTime arg1 arg2</code></td>
<td>Returns the time arg2 as formatted using the pattern arg1.</td>
</tr>
<tr>
<td><code>approxDuration arg1</code></td>
<td>Returns the approximate duration of arg1 in a 'human-friendly' format ("3 seconds", "2 months", "5 years") etc.</td>
</tr>
<tr>
<td><code>uppercase arg1</code></td>
<td>Returns arg1 converted to uppercase.</td>
</tr>
<tr>
<td><code>lowercase arg1</code></td>
<td>Returns arg1 converted to lowercase.</td>
</tr>
<tr>
<td><code>pluralize arg1 arg2 arg3</code></td>
<td>If arg1 equals 1 then return arg2, otherwise return arg3.</td>
</tr>
<tr>
<td><code>slugify arg1</code></td>
<td>Returns the lowercase of arg1 with all non-ASCII characters and punctuation removed (expect underscores and hyphens). Whitespaces are also replaced with a hyphen.</td>
</tr>
<tr>
<td><code>safeHTML arg1</code></td>
<td>Output the verbatim value of arg1 without escaping the content. This should only be used when arg1 is from a trusted source.</td>
</tr>
<tr>
<td><code>join arg1 arg2</code></td>
<td>Returns the values in slice arg1 joined using the separator arg2.</td>
</tr>
<tr>
<td><code>incr arg1</code></td>
<td>Increments arg1 by 1.</td>
</tr>
<tr>
<td><code>decr arg1</code></td>
<td>Decrements arg1 by 1.</td>
</tr>
<tr>
<td><code>formatInt arg1</code></td>
<td>Returns arg1 formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>formatFloat arg1 arg2</code></td>
<td>Returns arg1 rounded to arg2 decimal places and formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>yesNo arg1</code></td>
<td>Returns "Yes" if arg1 is true, or "No" if arg1 is false.</td>
</tr>
<tr>
<td><code>urlSetParam arg1 arg2 arg3</code></td>
<td>Returns the URL arg1 with the key arg2 and value arg3 added to the query string parameters.</td>
</tr>
<tr>
<td><code>urlDelParam arg1 arg2</code></td>
<td>Returns the URL arg1 with the key arg2 (and corresponding value) removed from the query string parameters.</td>
</tr>
</tbody>
</table>
<p>To add another custom template function, define the function in <code>internal/funcs/funcs.go</code> and add it to the <code>TemplateFuncs</code> map. For example:</p>
<pre>
var TemplateFuncs = template.FuncMap{
    ...
    "yourFunction": yourFunction, 
}

func yourFunction(s string) (string, error) {
    // Do something...
}
</pre>
<h2>Static files</h2>
<p>By default, the files in the <code>assets/static</code> directory are served using Go's <code>http.Fileserver</code> whenever the application receives a <code>GET</code> request with a path beginning <code>/static/</code>. So, for example, if the application receives a <code>GET /static/css/main.css</code> request it will respond with the contents of the <code>assets/static/css/main.css</code> file.</p>
<p>If you want to change or remove this behavior you can by editing the <code>routes.go</code> file.</p>
<p>Note: The files in <code>assets/static</code> directory are embedded into your application binary and can be accessed via the <code>EmbeddedFiles</code> variable in <code>assets/efs.go</code>.</p>
<h2>Working with forms</h2>
<p>The codebase includes a <code>request.DecodePostForm()</code> function for automatically decoding HTML form data from a POST request into a struct, and <code>request.DecodeQueryString()</code> for decoding URL query strings into a struct. Behind the scenes decoding is managed using the <a href="https://github.com/go-playground/form">go-playground/form</a> package.</p>
<p>As an example, let's say you have a page with the following HTML form for creating a 'person' record and routing rule:</p>
<pre>
&lt;form action="/person/create" method="POST"&gt;
    &lt;div&gt;
        &lt;label&gt;Your name:&lt;/label&gt;
        &lt;input type="text" name="Name" value="{{.Form.Name}}"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;Your age:&lt;/label&gt;
        &lt;input type="number" name="Age" value="{{.Form.Age}}"&gt;
    &lt;/div&gt;
    &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
<pre>
func (app *application) routes() http.Handler {
    mux := flow.New()
    
    mux.HandleFunc("/person/create", app.createPerson, "GET", "POST")
    
    return mux
}
</pre>
<p>Then you can display and parse this form with a <code>createPerson</code> handler like this:</p>
<pre>
package main

import (
    "net/http"

    "github.com/wumbabum/home_assist/internal/request"
    "github.com/wumbabum/home_assist/internal/response"
)

func (app *application) createPerson(w http.ResponseWriter, r *http.Request) {
    type createPersonForm struct {
        Name string `form:"Name"`
        Age  int    `form:"Age"`
    }

    switch r.Method {
    case http.MethodGet:
        data := app.newTemplateData()

        // Add any default values to the form.
        data["Form"] = createPersonForm{
            Age: 21,
        }

        err := response.Page(w, http.StatusOK, data, "/path/to/page.tmpl")
        if err != nil {
            app.serverError(w, r, err)
        }

    case http.MethodPost:
        var form createPersonForm

        err := request.DecodePostForm(r, &amp;form)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }
    
        // Do something with the data in the form variable...
    }
}    
</pre>
<h2>Validating forms</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre>
package main

import (
    "net/http"

    "github.com/wumbabum/home_assist/internal/request"
    "github.com/wumbabum/home_assist/internal/response"
    "github.com/wumbabum/home_assist/internal/validator"
)

func (app *application) createPerson(w http.ResponseWriter, r *http.Request) {
    type createPersonForm struct {
        Name      string              `form:"Name"`
        Age       int                 `form:"Age"`
        Validator validator.Validator `form:"-"`
    }

    switch r.Method {
    case http.MethodGet:
        data := app.newTemplateData()

        // Add any default values to the form.
        data["Form"] = createPersonForm{
            Age: 21,
        }

        err := response.Page(w, http.StatusOK, data, "/path/to/page.tmpl")
        if err != nil {
            app.serverError(w, r, err)
        }

    case http.MethodPost:
        var form createPersonForm

        err := request.DecodePostForm(r, &amp;form)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }

        form.Validator.CheckField(form.Name != "", "Name", "Name is required")
        form.Validator.CheckField(form.Age != 0, "Age", "Age is required")
        form.Validator.CheckField(form.Age &gt;= 21, "Age", "Age must be 21 or over")

        if form.Validator.HasErrors() {
            data := app.newTemplateData()
            data["Form"] = form

            err := response.Page(w, http.StatusUnprocessableEntity, data, "/path/to/page.tmpl")
            if err != nil {
                app.serverError(w, r, err)
            }
            return
        }

        // Do something with the form information, like adding it to a database...
    }
}    
</pre>
<p>And you can display the error messages in your HTML form like this:</p>
<pre>
&lt;form action="/person/create" method="POST"&gt;
    {{if .Form.Validator.HasErrors}}
        &lt;p&gt;Something was wrong. Please correct the errors below and try again.&lt;/p&gt;
    {{end}}
    &lt;div&gt;
        &lt;label&gt;Your name:&lt;/label&gt;
        {{with .Form.Validator.FieldErrors.Name}}
            &lt;span class='error'&gt;{{.}}&lt;/span&gt;
        {{end}}
        &lt;input type="text" name="Name" value="{{.Form.Name}}"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;Your age:&lt;/label&gt;
        {{with .Form.Validator.FieldErrors.Age}}
            &lt;span class='error'&gt;{{.}}&lt;/span&gt;
        {{end}}
        &lt;input type="number" name="Age" value="{{.Form.Age}}"&gt;
    &lt;/div&gt;
    &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Sending JSON responses</h2>
<p>JSON responses and a specific HTTP status code can be sent using the <code>response.JSON()</code> function. The <code>data</code> parameter can be any JSON-marshalable type.</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<h2>Parsing JSON requests</h2>
<p>HTTP requests containing a JSON body can be decoded using the <code>request.DecodeJSON()</code> function. For example, to decode JSON into an <code>input</code> struct:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Note: The target decode destination passed to <code>request.DecodeJSON()</code> (which in the example above is <code>&amp;input</code>) must be a non-nil pointer.</p>
<p>The <code>request.DecodeJSON()</code> function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the <code>app.badRequest()</code> helper.</p>
<p>There is also a <code>request.DecodeJSONStrict()</code> function, which works in the same way as <code>request.DecodeJSON()</code> except it will return an error if the request contains any JSON fields that do not match a name in the the target decode destination.</p>
<h2>Validating JSON requests</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age &gt;= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}    
</pre>
<p>The <code>app.failedValidation()</code> helper will send a <code>422</code> status code along with any validation error messages. For the example above, the JSON response will look like this:</p>
<pre>
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}    
</pre>
<h2>Working with the database</h2>
<p>This codebase is set up to use PostgreSQL with the <a href="https://github.com/lib/pq">lib/pq</a> driver. You can control which database you connect to using the <code>DB_DSN</code> environment variable to pass in a DSN, or by adapting the default value in <code>run()</code>.</p>
<p>The codebase is also configured to use <a href="https://github.com/jmoiron/sqlx">jmoiron/sqlx</a>, so you have access to the whole range of sqlx extensions as well as the standard library <code>Exec()</code>, <code>Query()</code> and <code>QueryRow()</code> methods .</p>
<p>The database is available to your handlers, middleware and helpers via the <code>application</code> struct. If you want, you can access the database and carry out queries directly. For example:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", "Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Generally though, it's recommended to isolate your database logic in the <code>internal/database</code> package and extend the <code>DB</code> type to include your own methods. For example, you could create a <code>internal/database/people.go</code> file containing code like:</p>
<pre>
type Person struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Age   int    `db:"age"`
}

func (db *DB) NewPerson(name string, age int) error {
    _, err := db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", name, age)
    return err
}

func (db *DB) GetPerson(id int) (Person, error) {
    var person Person
    err := db.Get(&amp;person, "SELECT * FROM people WHERE id = $1", id)
    return person, err
}
</pre>
<p>And then call this from your handlers:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    err := app.db.NewPerson("Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<h2>Managing SQL migrations</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily create and work with database migrations:</p>
<table>
<tbody>
<tr>
<td><code>$ make migrations/new name=add_example_table</code></td>
<td>Create a new database migration in the <code>assets/migrations</code> folder.</td>
</tr>
<tr>
<td><code>$ make migrations/up</code></td>
<td>Apply all up migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/down</code></td>
<td>Apply all down migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/goto version=N</code></td>
<td>Migrate up or down to a specific migration (where N is the migration version number).</td>
</tr>
<tr>
<td><code>$ make migrations/force version=N</code></td>
<td>Force the database to be specific version without running any migrations.</td>
</tr>
<tr>
<td><code>$ make migrations/version</code></td>
<td>Display the currently in-use migration version.</td>
</tr>
</tbody>
</table>
<p>Hint: You can run <code>$ make help</code> at any time for a reminder of these commands.</p>
<p>These <code>Makefile</code> tasks are simply wrappers around calls to the <code>github.com/golang-migrate/migrate/v4/cmd/migrate</code> tool. For more information, please see the <a href="https://github.com/golang-migrate/migrate/tree/master/cmd/migrate">official documentation</a>.</p>
<p>By default all 'up' migrations are automatically run on application startup using embeded files from the <code>assets/migrations</code> directory. You can disable this by setting the <code>DB_AUTOMIGRATE</code> environment variable to <code>false</code>.</p>
<h2>Logging</h2>
<p>Leveled logging is supported using the <a href="https://pkg.go.dev/log/slog">slog</a> and <a href="https://github.com/lmittmann/tint">tint</a> packages.</p>
<p>By default, a logger is initialized in the <code>main()</code> function. This logger writes all log messages above <code>Debug</code> level to <code>os.Stdout</code>.</p>
<pre>
logger := slog.New(tint.NewHandler(os.Stdout, &amp;tint.Options{Level: slog.LevelDebug}))
</pre>
<p>Feel free to customize this further as necessary.</p>
<p>Also note: Any messages that are automatically logged by the Go <code>http.Server</code> are output at the <code>Warn</code> level.</p>
<h2>Using Basic Authentication</h2>
<p>The <code>cmd/web/middleware.go</code> file contains a <code>basicAuth</code> middleware that you can use to protect your application — or specific application routes — with HTTP basic authentication.</p>
<p>You can try this out by visiting the <a href="https://localhost:5749/restricted-basic-auth">https://localhost:5749/restricted-basic-auth</a> endpoint in any web browser and entering the default user name and password:</p>
<pre>
User name: admin
Password:  pa55word
</pre>
<p>You can change the user name and password by setting the <code>BASIC_AUTH_USERNAME</code> environment variable and <code>BASIC_AUTH_HASHED_PASSWORD</code> environment variable. For example:</p>
<pre>
$ export BASIC_AUTH_USERNAME='alice'
$ export BASIC_AUTH_HASHED_PASSWORD='$2a$10$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
$ go run ./cmd/web
</pre>
<p>Note: You will probably need to wrap the username and password in <code>'</code> quotes to prevent your shell interpreting dollar and slash symbols as special characters.</p>
<p>The value for the <code>BASIC_AUTH_HASHED_PASSWORD</code> environment variable should be a bcrypt hash of the password, not the plaintext password itself. An easy way to generate the bcrypt hash for a password is to use the <code>gophers.dev/cmds/bcrypt-tool</code> package like so:</p>
<pre>
$ go run gophers.dev/cmds/bcrypt-tool@latest hash 'your_pa55word'
</pre>
<p>If you want to change the default values for username and password you can do so by editing the default command-line flag values in the <code>cmd/web/main.go</code> file.</p>
<h2 id="using-sessions">Using sessions</h2>
<p>The codebase is set up so that server-side sessions (using the <a href="https://github.com/alexedwards/scs">SCS</a> package) work out-of-the-box.</p>
<p>You can use them in your handlers like this:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    // Add the key "foo" and value "bar" to the session.
    app.sessionManager.Put(r.Context(), "foo", "bar")

    // Retrieve the value for the key "baz" from the session.
    baz := app.sessionManager.GetString(r.Context(), "baz")    
    ...
}
</pre>
<p>By default sessions are set to expire after 1 week. You can configure this along with other settings in the <code>cmd/web/main.go</code> file by changing the <code>sessionManager</code> struct values. For example:</p>
<pre>
sessionManager := scs.New()
...
sessionManager.Lifetime = 3 * time.Hour
sessionManager.IdleTimeout = 20 * time.Minute
sessionManager.Cookie.HttpOnly = false
sessionManager.Cookie.Persist = false
sessionManager.Cookie.SameSite = http.SameSiteStrictMode
sessionManager.Cookie.Partitioned = true
</pre>
<p>The session cookie name is randomized on a per-application basis, in order to reduce the risk of cookie conflicts if you are developing multiple applications on the same machine. The default session cookie name takes the form <code>"session_{8 random characters}"</code>, and this can be configured to a different value at runtime using the <code>SESSION_COOKIE_NAME</code> environment variable</p>
<p>For more information please see the <a href="https://github.com/alexedwards/scs">documentation for the SCS package</a>.</p>
<h2>Admin tasks</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily run common admin tasks:</p>
<table>
<tbody>
<tr>
<td><code>$ make tidy</code></td>
<td>Format all code using <code>go fmt</code> and tidy the <code>go.mod</code> file.</td>
</tr>
<tr>
<td><code>$ make audit</code></td>
<td>Run <code>go vet</code>, <code>staticheck</code>, <code>govulncheck</code>, execute all tests and verify required modules.</td>
</tr>
<tr>
<td><code>$ make test</code></td>
<td>Run all tests.</td>
</tr>
<tr>
<td><code>$ make test/cover</code></td>
<td>Run all tests and outputs a coverage report in HTML format.</td>
</tr>
<tr>
<td><code>$ make build</code></td>
<td>Build a binary for the <code>cmd/web</code> application and store it in the <code>/tmp/bin</code> folder.</td>
</tr>
<tr>
<td><code>$ make run</code></td>
<td>Build and then run a binary for the <code>cmd/web</code> application.</td>
</tr>
<tr>
<td><code>$ make run/live</code></td>
<td>Build and then run a binary for the <code>cmd/web</code> application (uses live reloading).</td>
</tr>
</tbody>
</table>
<h2>Live reload</h2>
<p>When you use <code>make run/live</code> to run the application, the application will automatically be rebuilt and restarted whenever you make changes to any files with the following extensions:</p>
<pre>
.go
.tpl, .tmpl, .html
.css, .js, .sql
.jpeg, .jpg, .gif, .png, .bmp, .svg, .webp, .ico
</pre>
<p>Behind the scenes the live reload functionality uses the <a href="https://github.com/cosmtrek/air">cosmtrek/air</a> tool. You can configure how it works (including which file extensions and folders are watched for changes) by editing the <code>Makefile</code> file.</p>
<h2>Running background tasks</h2>
<p>A <code>backgroundTask()</code> helper is included in the <code>cmd/web/helpers.go</code> file. You can call this in your handlers, helpers and middleware to run any logic in a separate background goroutine. This useful for things like sending emails, or completing slow-running jobs.</p>
<p>You can call it like so:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    app.backgroundTask(r, func() error {
        // The logic you want to execute in a background task goes here.
        // It should return an error, or nil.
        err := doSomething()
        if err != nil {
            return err
        }

        return nil
    })
    
    ...
}
</pre>
<p>Using the <code>backgroundTask()</code> helper will automatically recover any panics in the background task logic, and when performing a graceful shutdown the application will wait for any background tasks to finish running before it exits.</p>
<h2>Application version</h2>
<p>The application version number is defined in a <code>Get()</code> function in the <code>internal/version/version.go</code> file. Feel free to change this as necessary.</p>
<pre>
package version

func Get() string {
    return "0.0.1"
}
</pre>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>github.com/wumbabum/home_assist</code>. If you want to change this please find and replace all instances of <code>github.com/wumbabum/home_assist</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Live reload
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
AutoHTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Background tasks
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
JSON:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
JSON:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Routing
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Handlers
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Notifications
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
